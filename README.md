### Introduction
The [minimax algorithm](https://en.wikipedia.org/wiki/Minimax) is a well-known method of implementing a chess computer. Essentially, the algorithm constructs a tree, where nodes denote board states and edges denote moves, of a certain depth. Note that this requires being able to enumerate all possible moves given some board state. Suppose I fix the depth of my tree to be 5; then the leaf nodes of the tree denote all possible board states 5 moves from now.

I then need to have some function that assigns a value to each leaf node. In chess, such a function could be the sum of my own material minus the sum of my opponent's material. We now arrive at the core idea of the algorithm -- we want to somehow deduce which move we should make *now*, given the values of all possible leaf nodes 5 moves from now. In particular, we want to maximize our value, knowing that our opponent while simultaneously be minimizing our value. This yields the minimax algorithm, where the value of a node is the maximum of its children's values at even depths, and the minimum of its children's values at odd depths.

Crucially, there is nothing about this algorithm that is specific to chess. In fact, it can be applied to a wide variety of two-player adversarial games, such as Go, Tic-Tac-Toe, and Dots and Boxes. This library is an attempt to provide a simple means of implementing the minimax algorithm for any such game.
